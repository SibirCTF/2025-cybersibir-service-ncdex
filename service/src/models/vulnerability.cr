require "json"
require "db"
require "pg"

class Vulnerability
  include JSON::Serializable
  include DB::Serializable

  property id : Int32
  property seller_id : Int32
  property cve_code : String
  property title : String
  property description : String
  property exploit : String
  property exploit_type : String
  property platform : String
  property price : Int32
  property status : String
  property severity : String
  property created_at : Time

  def initialize(
    @id,
    @seller_id,
    @cve_code,
    @title,
    @description,
    @exploit,
    @exploit_type,
    @platform,
    @price,
    @status,
    @severity,
    @created_at,
  )
  end

  def self.create(
    seller_id,
    title,
    description,
    exploit,
    exploit_type,
    platform,
    price,
  )
    cve_code = CVEGenerator.generate
    status, severity = CVEGenerator.calculate_severity(title, description)

    query = <<-SQL
      INSERT INTO vulnerabilities
        (seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at)
      VALUES
        ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, now())
      RETURNING
        id, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at
    SQL

    vuln = nil
    DBC.query(query, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity) do |rs|
      vuln = Vulnerability.from_rs(rs).first
    end

    vuln
  end

  def self.find(vuln_id)
    query = <<-SQL
      SELECT
        id, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at
      FROM vulnerabilities
      WHERE id = $1
    SQL

    result = DBC.query(query, vuln_id)
    v = Vulnerability.from_rs(result)
    v.first?
  end

  def self.all
    query = <<-SQL
      SELECT
        id, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at
      FROM vulnerabilities
      WHERE NOT status = 'manual_review'
    SQL

    Vulnerability.from_rs(DBC.query(query))
  end

  def self.paginated(page : Int32, per_page : Int32, filters : Hash(String, String?))
    per_page = per_page.clamp(1, 100)
    offset = Math.max((page - 1) * per_page, 0)

    conditions = [] of String
    params = [] of DB::Any
    param_index = 1

    if exploit_type = filters["exploit_type"].presence
      conditions << "exploit_type = $#{param_index}"
      params << exploit_type
      param_index += 1
    end

    if platform = filters["platform"].presence
      conditions << "platform = $#{param_index}"
      params << platform
      param_index += 1
    end

    if severity = filters["severity"].presence
      conditions << "severity = $#{param_index}"
      params << severity
      param_index += 1
    end

    # Всегда есть статус (по умолчанию available)
    status = filters["status"].presence || "available"
    conditions << "status = $#{param_index}"
    params << status
    param_index += 1

    if search = filters["search"].presence
      conditions << "(title ILIKE '%' || $#{param_index} || '%' OR description ILIKE '%' || $#{param_index} || '%')"
      params << search
      param_index += 1
    end

    where_clause = conditions.any? ? "WHERE #{conditions.join(" AND ")}" : ""

    query = <<-SQL
      SELECT id, seller_id, cve_code, title, description, exploit, exploit_type,
            platform, severity, status, price, created_at
      FROM vulnerabilities
      #{where_clause}
      ORDER BY created_at DESC
      LIMIT #{per_page + 1} OFFSET #{offset}
    SQL

    vulnerabilities = [] of Vulnerability
    DBC.query(query, args: params) do |rs|
      vulnerabilities = Vulnerability.from_rs(rs)
    end

    has_more = vulnerabilities.size > per_page
    vulnerabilities = vulnerabilities[0...per_page] if has_more

    {vulnerabilities, has_more}
  end

  def self.all_own(user_id : Int32)
    query = <<-SQL
      SELECT
        id, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at
      FROM vulnerabilities
      WHERE NOT status = 'manual_review' AND seller_id = $1
    SQL

    Vulnerability.from_rs(DBC.query(query, user_id))
  end

  def self.all_popular
    query = <<-SQL
      SELECT
        id, seller_id, cve_code, title, description, exploit, exploit_type, platform, price, status, severity, created_at
      FROM vulnerabilities
      WHERE NOT severity = 'none'
      ORDER BY price DESC
      LIMIT 5
    SQL

    Vulnerability.from_rs(DBC.query(query))
  end

  def update(
    title : String? = nil,
    description : String? = nil,
    exploit : String? = nil,
    exploit_type : String? = nil,
    platform : String? = nil,
    price : Int32? = nil,
    status : String? = nil,
  )
    self.title = title || self.title
    self.description = description || self.description
    self.exploit = exploit || self.exploit
    self.exploit_type = exploit_type || self.exploit_type
    self.platform = platform || self.platform
    self.price = price || self.price
    self.status = status || self.status

    query = <<-SQL
      UPDATE vulnerabilities
      SET
        title = $1,
        description = $2,
        exploit = $3,
        exploit_type = $4,
        platform = $5,
        price = $6,
        status = $7
      WHERE id = $8
    SQL

    result = DBC.exec(
      query,
      self.title,
      self.description,
      self.exploit,
      self.exploit_type,
      self.platform,
      self.price,
      self.status,
      self.id
    )

    result.rows_affected > 0
  end

  def buy(buyer_id : Int32)
    balance_query = "SELECT balance FROM users WHERE id = $1"
    balance = DBC.query_one(balance_query, buyer_id, &.read(Int32))

    return nil if balance < self.price # Недостаточно средств
    transaction_id = nil
    DBC.transaction do |tx|
      tx.connection.exec(
        "UPDATE users SET balance = balance - $1 WHERE id = $2",
        self.price, buyer_id
      )

      tx.connection.exec(
        "UPDATE users SET balance = balance + $1 WHERE id = $2",
        self.price, self.seller_id
      )

      transaction_id = tx.connection.query_one(<<-SQL, buyer_id, self.seller_id, self.price, self.id, &.read(Int32))
        INSERT INTO transactions
          (from_user, to_user, amount, transaction_type, vulnerability_id, created_at)
        VALUES
          ($1, $2, $3, 'purchase', $4, now())
        RETURNING id
      SQL

      tx.connection.exec("UPDATE vulnerabilities SET status = 'sold' WHERE id = $1", self.id)
    end
    transaction_id
  end

  def platform_icon
    VulnMappings::PLATFORM_ICONS[platform] || "💻"
  end

  def type_icon
    VulnMappings::TYPE_ICONS[exploit_type] || "❓"
  end

  def short_description
    description.split(" ")[..4].join(" ") + "..."
  end
end
